package dmit2015.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Objects;
import java.util.Optional;

/**
 * The persistent class for the phones database table.
 */

@Getter
@Setter
@NoArgsConstructor
@Entity                     // This class is map to database table with the same name as the class name
@Table(name = "Phone")     // This entity class maps to a database table named phones
public class Phone implements Serializable {

    @Id                 // This is the primary key field
    @GeneratedValue(strategy = GenerationType.IDENTITY)     // This primary key field is generated by the database
    @Column(name = "phoneId")
    private Long id;

    @Column(length = 40, nullable = false)
    @NotBlank(message = "The Model field is required.")
    @Size(min = 3, max = 40, message = "The field Model must be a string with a minimum length of {min} and a maximum length of {max}.")
    private String model;

    @Column(nullable = false)
    @NotNull(message = "The Release Date field is required")
    private LocalDate releaseDate;

    @DecimalMin(value = "1.00",message = "The price must be a number between 0.00 and 5000.00.")
    @DecimalMax(value = "5000.00",message = "The price must be a number between 0.00 and 5000.00.")
    private BigDecimal price;

    @Column(nullable = false, length = 30)
    @NotBlank(message = "The field Brand is required.")
    @Pattern(regexp = "^[A-Z]+[a-zA-Z\\s]*$",  // Must only use letters.
                                            // The first letter is required to be uppercase. White space, numbers, and special characters are not allowed.
            message = "The field Brand must match the regular expression '^[A-Z]+[a-zA-Z\\s]*$'.")
    private String brand;

    @Column(nullable = false, length = 10)
    @NotBlank(message = "The field Operating System is required.")
    private String operatingSystem;


    @Version
    private Integer version;

    @Column(nullable = false)
    private LocalDateTime createTime;

    private LocalDateTime updateTime;

    @PrePersist
    private void beforePersist() {
        createTime = LocalDateTime.now();
    }

    @PreUpdate
    private void beforeUpdate() {
        updateTime = LocalDateTime.now();
    }
    @Override
    public boolean equals(Object obj) {
        return (
                (obj instanceof Phone other) &&
        Objects.equals(id, other.id)
            );
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
    public static Optional<Phone> parseCsv(String line) {
        Optional<Phone> optionalPhone = Optional.empty();
        final var DELIMITER = ",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)";
        String[] tokens = line.split(DELIMITER, -1);  // The -1 limit allows for any number of fields and not discard trailing empty fields
        /**
         * The order of the columns are:
         * 0 - model
         * 1 - releaseDate
         * 2 - brand
         * 3 - price
         * 4 - operatingSystem
         */
        if (tokens.length == 5) {
            Phone parsedMovie = new Phone();

            try {
                String model = tokens[0].replaceAll("\"","");
                LocalDate releaseDate = LocalDate.parse(tokens[1]);
                String brand = tokens[2].replaceAll("\"","");
                BigDecimal price = BigDecimal.valueOf(Double.parseDouble(tokens[3]));
                String operatingSystem = tokens[4].replaceAll("\"","");

                parsedMovie.setModel(model);
                parsedMovie.setReleaseDate(releaseDate);
                parsedMovie.setBrand(brand);
                parsedMovie.setPrice(price);
                parsedMovie.setOperatingSystem(operatingSystem);

                optionalPhone = Optional.of(parsedMovie);
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }

        return optionalPhone;
    }
}